// Time Complexity : O(N^2) or V+E
// Space Complexity : O(N)
// Did this code successfully run on Leetcode : yes
// Any problem you faced while coding this : no
// Approach : find number of disconnected components, number of nodes in each such component and number of infected nodes in each component
/// if number of infected if component is 1, then we can possibly disable it, compute number of nodes we can save.
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int colors[] = new int[graph.length];
        Arrays.fill(colors, -1);
        int n = graph.length;
        int color = 0;
        for(int i=0;i<n;i++){
            if(colors[i]==-1){
                dfs(graph, i, color, colors);
                color++;
            }
        }
        int groups[] = new int[color];
        int infected[] = new int[color];
        for(int i=0;i<n;i++){
            groups[colors[i]]++;
        }
        for(int i=0;i<initial.length;i++){
            infected[colors[initial[i]]]++;
        }
        System.out.println(Arrays.toString(groups));
        System.out.println(Arrays.toString(infected));
        int result = Integer.MAX_VALUE;
        for(int i=0;i<initial.length;i++){
            int currInf = initial[i];
            if(infected[colors[currInf]] == 1){
                //update result
                if(result==Integer.MAX_VALUE){
                    result = currInf;
                }
                else if(groups[colors[result]]<groups[colors[currInf]]){
                    result = currInf;
                }
                else if(groups[colors[result]] == groups[colors[currInf]]){
                    result = Math.min(result, currInf);
                }
            }
        }
        if(result==Integer.MAX_VALUE){
            for(int i=0;i<initial.length;i++){
                result = Math.min(result, initial[i]);
            }
        }
        return result;
    }
    private void dfs(int graph[][], int i, int color, int colors[]){
        //base
        if(colors[i]!=-1){
            return;
        }
        //logic
        System.out.println("Assigning.."+color+" "+i);
        colors[i] = color;
        for(int j=0;j<graph.length;j++){
            if(graph[i][j]==1){
                if(i==j) continue;
                dfs(graph, j, color, colors);
            }
        }
    }
}